"a standard .vimrc
"silent usage: map <silent> or execute silent command, to do not show command on bottom command line
"set term=dtterm            " display its text when it is closed
set term=xterm
set autowrite
set linebreak
"set whichwrap=b,s,<,>,[,]
set laststatus=2
set showmode
set nocp
"hi Normal ctermgb=#006699 guibg=green
set nocompatible
set confirm
if has("linux")
    set shell=/bin/bash
endif
"echo $VIM
"echo $HOME
set nobackup
"set backup
"set backupext=.backup  "backup file suffix
"set backupdir=~/.vim/backup   "default dir
"set backupskip= 取消对指定目录下文件的备份
set backspace=indent,eol,start
"filetype on                " check file type
set history=500
set background=dark
set autoindent          " auto indent
set smartindent         " format
set winaltkeys=no        "Alt组合键不映射到菜单上
set cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,>1s,=1s,:1s
set shiftwidth=4
set tabstop=4
set softtabstop=4
set showmatch           " for ( [ {
set guioptions-=T
set vb t_vb=
set ruler
set rulerformat=%20(%2*%<%f%=\ %m%r\ %3l\ %c\ %p%%%)
set nohls               " no highlight  set hlsearch
set incsearch           " for / or ?
set noexpandtab
set showcmd         "输入的命令显示出来
"set autochdir " always switch to the current file directory
set incsearch
set softtabstop=4
set tabstop=4
set showmatch
set confirm
set wildmenu
set backspace=2
set selection=exclusive
"when display characters
set termencoding=chinese
"when open files
"if has("multi_byte")
	" set fileformats=unix,mac,dos
    set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,latin1 "gb2312 in unix and cp936 in windows is chinese
    "vim buffer encoding, for copy & delete
    if has("win32")
        set encoding=chinese
    else
        set encoding=utf-8
    endif
"    when create new files
    set fileencoding=utf-8
    if v:lang =~?'^\(zh\)\|\(ja\)\|\(ko\)'
        set ambiwidth=double
    endif
    if has("win32")
        source $VIMRUNTIME/delmenu.vim
        source $VIMRUNTIME/menu.vim
"        language messages zh_CN.utf-8
    endif
"else
"    echoerr "sorry, vim can not support multi_byte."
"endif
if has("win32")
    set guifont=Consolas:h14:cANSI
else
    set guifont=Monospace\ 14
endif
set noignorecase smartcase
set sessionoptions-=curdir
set sessionoptions+=sesdir
"与windows共享剪贴板
set clipboard+=unnamed
set nu
" 保存全局变量
set viminfo+=!
" 带有如下符号的单词不要被换行分割
set iskeyword+=_,$,@,%,#,48-57,192-255        "选项定义了一个word中可以包含哪些字符:"@"在这里代指所有的字母. "48-57"指ASCII码从48到57的那些字符, 即0到9. "192-255"是可打印拉丁字母.
set showcmd
set autoread  "自动读取文件，当文件在外部被修改时
"set leader
let g:mapleader = "\\"
set fillchars=vert:\ ,stl:\ ,stlnc:\  "在被分割的窗口间显示空白，便于阅读
"colorscheme murphy "for golang
colorscheme evening " for c
nmap <leader>cb :color blue<CR>
nmap <leader>cd :color desert<CR>
nmap <leader>ce :color evening<CR>
nmap <leader>cm :color murphy<CR>
"set background=light

set formatoptions=tcrqn "自动格式化
" 状态行显示的内容（包括文件类型和解码）
set statusline=\ [File]\ %F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}\ %r%{CurrectDir()}%h\ %=\ [Line]%l/%L\ %=\[%P]
""set so = 3  "上下移动时，留三行
set magic
set cmdheight=1
""set completeopt = longest,menu "自动完成"
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" auto complete
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" command line
set wildmenu
set wildmode=longest:full
"文件类型"
set ffs=unix
""highlight OverLength ctermbg=red ctermfg=white guibg=#592929
""match OverLength /\%81v.\+/
if version >= 703
    set colorcolumn=80,100
"   set cc=80,100
endif

inoremap <leader>{  {}<esc>i
inoremap <leader>[  []<esc>i
inoremap <leader>(  ()<esc>i
inoremap <leader>'  ''<esc>i
inoremap <leader>"  ""<esc>i
"for c\c++
nmap <leader>hs q:
autocmd FileType h,hpp,c,cc,cpp,cxx set list
autocmd FileType h,hpp,c,cc,cpp,cxx set listchars=tab:>-,trail:-,extends:>,precedes:<,eol:$
autocmd FileType h,hpp,c,cc,cpp,cxx set cindent | set shiftwidth=4 | set expandtab " 用 space 代替 tab

" add file header
nmap <leader>he  : call TitleDet()<CR>
func! AddTitle()
    if &filetype == "sh"
		call append(0, "\#!/usr/bin/env bash")
		call append(1, "# ******************************************************")
		call append(2, "# DESC    : ")
		call append(3, "# AUTHOR  : Alex Stocks")
		call append(4, "# VERSION : 1.0")
		call append(5, "# LICENCE : LGPL V3")
		call append(6, "# EMAIL   : alexstocks@foxmail.com")
		call append(7, "# MOD     : ".strftime("%Y-%m-%d %H:%M"))
		call append(8, "# FILE    : ".expand("%:t"))
		call append(9, "# ******************************************************")
    elseif &filetype == "h" || &filetype == "hpp"
		call append(0, "/******************************************************")
		call append(1, "# DESC    : ")
		call append(2, "# AUTHOR  : Alex Stocks")
		call append(3, "# VERSION : 1.0")
		call append(4, "# LICENCE : LGPL V3")
		call append(5, "# EMAIL   : alexstocks@foxmail.com")
		call append(6, "# MOD     : ".strftime("%Y-%m-%d %H:%M"))
		call append(7, "# FILE    : ".expand("%:t"))
		call append(8, "******************************************************/")
		call append(9, "")
		call append(10, "#ifndef __SDK_FUNC_H__")
		call append(11, "#define __SDK_FUNC_H__")
		call append(12, "")
		call append(13, "#if (defined(__cplusplus))")
		call append(14, "    extern \"C\" {")
		call append(15, "#endif")
		call append(16, "")
		call append(18, "#include <stdio.h>")
		call append(19, "")
		call append(21, "")
		call append(21, "#if (defined(__cplusplus))")
		call append(22, "    }")
		call append(23, "#endif")
    elseif &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
		call append(0, "/******************************************************")
		call append(1, "# DESC    : ")
		call append(2, "# AUTHOR  : Alex Stocks")
		call append(3, "# VERSION : 1.0")
		call append(4, "# LICENCE : LGPL V3")
		call append(5, "# EMAIL   : alexstocks@foxmail.com")
		call append(6, "# MOD     : ".strftime("%Y-%m-%d %H:%M"))
		call append(7, "# FILE    : ".expand("%:t"))
		call append(8, "******************************************************/")
		call append(9, "")
		call append(10, "#if (defined(__cplusplus))")
		call append(11, "    extern \"C\" {")
		call append(12, "#endif")
		call append(13, "")
		call append(14, "#include <stdio.h>")
		call append(15, "#include <stdlib.h>")
		call append(16, "")
		call append(17, "")
		call append(18, "#if (defined(__cplusplus))")
		call append(19, "    }")
		call append(20, "#endif")
    elseif &filetype == "go"
		call append(0, "/******************************************************")
		call append(1, "# DESC    : ")
		call append(2, "# AUTHOR  : Alex Stocks")
		call append(3, "# VERSION : 1.0")
		call append(4, "# LICENCE : LGPL V3")
		call append(5, "# EMAIL   : alexstocks@foxmail.com")
		call append(6, "# MOD     : ".strftime("%Y-%m-%d %H:%M"))
		call append(7, "# FILE    : ".expand("%:t"))
		call append(8, "******************************************************/")
		call append(9, "")
		call append(10, "package main")
		call append(11, "")
		call append(12, "import (")
		call append(13, "    \"fmt\"")
		call append(14, ")")
		call append(15, "")
		call append(16, "func main() {")
		call append(17, "    fmt.Println(\"hello\", world\)")
		call append(18, "}")
    elseif &filetype == "python"
		call append(0, "\#!/bin/python")
		call append(1, "# ******************************************************")
		call append(2, "# DESC    : ")
		call append(3, "# AUTHOR  : Alex Stocks")
		call append(4, "# VERSION : 1.0")
		call append(5, "# LICENCE : LGPL V3")
		call append(6, "# EMAIL   : alexstocks@foxmail.com")
		call append(7, "# MOD     : ".strftime("%Y-%m-%d %H:%M"))
		call append(8, "# FILE    : ".expand("%:t"))
		call append(9, "# ******************************************************")
    elseif &filetype == "lua"
		call append(0, "--[[ #!/usr/bin/env lua --]]")
		call append(1, "--------------------------------------------------------")
		call append(2, "-- DESC    : ")
		call append(3, "-- AUTHOR  : Alex Stocks")
		call append(4, "-- VERSION : 1.0")
		call append(5, "-- LICENCE : LGPL V3")
		call append(6, "-- EMAIL   : alexstocks@foxmail.com")
		call append(7, "-- MOD     : ".strftime("%Y-%m-%d %H:%M"))
		call append(8, "-- FILE    : ".expand("%:t"))
		call append(9, "--------------------------------------------------------")
	else
		call append(0, "\# nginx configure script")
		call append(1, "# ******************************************************")
		call append(2, "# DESC    : ")
		call append(3, "# AUTHOR  : Alex Stocks")
		call append(4, "# VERSION : 1.0")
		call append(5, "# LICENCE : LGPL V3")
		call append(6, "# EMAIL   : alexstocks@foxmail.com")
		call append(7, "# MOD     : ".strftime("%Y-%m-%d %H:%M"))
		call append(8, "# FILE    : ".expand("%:t"))
		call append(9, "# ******************************************************")
	endif
    echohl WarningMsg | echo "Successful in adding copyright." | echohl None
endfunc

func! UpdateTitle()
     normal m'
     execute '/# MOD/s@:.*$@\=strftime(": %Y-%m-%d %H:%M")@'
     normal ''
     normal mk
	 execute '/# FILE/s@:.*$@\=": ".expand("%:t")@'
     execute "noh"
     normal 'k
     echohl WarningMsg | echo "Successful in updating the copyright." | echohl None
endfunc

func! TitleDet()
    let n=1
    while n < 15
        let line = getline(n)
        if line =~ '^\#\s*\S*MOD\S*.*$'
			call UpdateTitle()
            return
        endif
        let n = n + 1
    endwhile
    call AddTitle()
endfunc

" add function declaration
nmap <leader>fd  : call FunctionDeclare()<CR>
func! FunctionDeclare()
	if &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
        call append(line(".") + 0, "/**")
        call append(line(".") + 1, " * description    : write <br/><br/>")
        call append(line(".") + 2, " *")
        call append(line(".") + 3, " * in-@fd         : file decription")
        call append(line(".") + 4, " * in-out@buf     : buffer")
        call append(line(".") + 5, " * in-@buf_len    : buffer len")
        call append(line(".") + 6, " *")
        call append(line(".") + 7, " * out-@ret       : if successful, ret is 0; otherwise -1 instead.")
        call append(line(".") + 8, " **/")
        call append(line(".") + 9, "int func(int fd, char* buf, int buf_len);")
    elseif &filetype == "go"
        call append(line(".") + 0, "/**")
        call append(line(".") + 1, " * description     : write <br/><br/>")
        call append(line(".") + 2, " *")
        call append(line(".") + 3, " * in-@fd          : file decription")
        call append(line(".") + 4, " * in-out@buf      : buffer")
        call append(line(".") + 5, " * in-@buf_len     : buffer len")
        call append(line(".") + 6, " *")
        call append(line(".") + 7, " * out-@err        : if successful, err is 0; err.String() instead.")
        call append(line(".") + 8, " **/")
        call append(line(".") + 9, "func Func(fd int, buf string, buf_len int)(err error){")
        call append(line(".") + 10, "    fmt.Println(\"hello %T %#v\", v, v)")
        call append(line(".") + 11, "}")
	endif
	normal ddW
endfunc

" add remark
nmap <leader>re  : call Remark()<CR>
func! Remark()
	if &filetype == "sh"
        call append(line(".") + 0, "#######################")
        call append(line(".") + 1, "#")
        call append(line(".") + 2, "#")
        call append(line(".") + 3, "#######################")
    elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"  || &filetype == "go"
        call append(line(".") + 0, "//////////////////////////////////////////")
        call append(line(".") + 1, "//")
        call append(line(".") + 2, "//")
        call append(line(".") + 3, "//////////////////////////////////////////")
    elseif &filetype == "python"
        call append(line(".") + 0, "\"\"\"")
        call append(line(".") + 1, "# Curl")
        call append(line(".") + 2, "#")
        call append(line(".") + 3, "\"\"\"")
    endif
	normal ddw
endfunc

" add remark
nmap <leader>r8  : call RemarkEx()<CR>
func! RemarkEx()
    if &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"  || &filetype == "go"
        call append(line(".") + 0, "/**")
        call append(line(".") + 1, " *")
        call append(line(".") + 2, " *")
        call append(line(".") + 3, " *")
        call append(line(".") + 4, " **/")
    endif
	normal ddw
endfunc

" add function defination
nmap <leader>fu  : call FunctionDefine()<CR>
func! FunctionDefine()
	if &filetype == "sh"
        call append(line(".") + 0, "function udp_state {")
        call append(line(".") + 1, "    idx = 0")
        call append(line(".") + 2, "    while [[ idx -lt $NUM ]]; do")
        call append(line(".") + 3, "     ((idx++))")
        call append(line(".") + 4, "    done")
        call append(line(".") + 5, "}")
        call append(line(".") + 6, "export -f udp_state")
    elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
        call append(line(".") + 0, "int func(int fd, char* buf, int buf_len)")
        call append(line(".") + 1, "{")
        call append(line(".") + 2, "    return 0;")
        call append(line(".") + 3, "}")
    elseif &filetype == "go"
        call append(line(".") + 0, "func Func()() {")
        call append(line(".") + 1, "    fmt.Println(\"hello %T %#v\", v, v)")
        call append(line(".") + 2, "}")
    elseif &filetype == "python"
        call append(line(".") + 0, "def Curl(host, port):")
        call append(line(".") + 1, "\"\"\" Curl \"\"\"")
        call append(line(".") + 2, "    connection = httplib.HTTPConnection(host, port)")
        call append(line(".") + 3, "    if not str:")
        call append(line(".") + 4, "        logging.warn(status)")
        call append(line(".") + 5, "        sys.exit(-1)")
        call append(line(".") + 6, "    return json.loads(result)")
    endif
	normal ddW
endfunc

nmap <leader>in  : call IncludeHeader()<CR>
nmap <leader>im  : call IncludeHeader()<CR>
func! IncludeHeader()
	if &filetype == "sh"
        call append(line(".") + 0, "source ./bash.public.h")
		normal ddW
    elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
        call append(line(".") + 0, "#include <>")
        call append(line(".") + 1, "#include \"\"")
		normal dd$
    elseif &filetype == "go"
        call append(line(".") + 0, "import (")
        call append(line(".") + 1, "    \"fmt\"")
        call append(line(".") + 2, ")")
		normal ddj2w
    elseif &filetype == "python"
        call append(line(".") + 0, "import sys")
        call append(line(".") + 1, "import os")
        call append(line(".") + 2, "import log")
		normal dd2jw
    endif
endfunc

nmap <leader>co  : call Const()<CR>
func! Const()
    if &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
        call append(line(".") + 0, "const int value = 3;")
		normal ddW
    elseif &filetype == "go"
        call append(line(".") + 0, "const (")
        call append(line(".") + 1, "    A = 1")
        call append(line(".") + 2, "    D = iota")
        call append(line(".") + 3, ")")
		normal ddjfow
    endif
endfunc

nmap <leader>ty  : call Typedef()<CR>
func! Typedef()
    if &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
        call append(line(".") + 0, "typedef A   A;")
		normal ddW
    elseif &filetype == "go"
        call append(line(".") + 0, "type INT int")
		normal ddW
    endif
endfunc
nmap <leader>ou  : call Output()<CR>
func! Output()
	if &filetype == "sh"
		call append(line("."), "echo ${idx}")
		normal dd3w
    elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
		call append(line("."), "    printf(\"%d\", idx);")
		normal dd2w
    elseif &filetype == "go"
        call append(line("."), "    fmt.Println(\"Hello:\", )")
		normal dd4w
    elseif &filetype == "python"
        call append(line("."), "    print(\"%s-%s\" % (v, v))")
		normal dd2w
    endif
endfunc

nmap <leader>if  : call ConditionIf()<CR>
func! ConditionIf()
	if &filetype == "sh"
		call append(line(".") + 0, "if [ $# -gt 0 ] ; then")
		call append(line(".") + 1, "    echo hello")
		call append(line(".") + 2, "fi")
		normal ddW
    elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
		call append(line(".") + 0, "    if (idx) {")
		call append(line(".") + 1, "        idx;")
		call append(line(".") + 2, "    }")
		normal ddfo2w
    elseif &filetype == "go"
        call append(line(".") + 0, "    if err != nil {")
        call append(line(".") + 1, "        fmt.Println(\"Error:\", err)")
        call append(line(".") + 2, "        break")
        call append(line(".") + 3, "        os.Exit(1)")
        call append(line(".") + 4, "    }")
		normal ddfow
    elseif &filetype == "python"
        call append(line(".") + 0, "    if ret != 0:")
        call append(line(".") + 1, "        ret")
		normal ddfow
    endif
endfunc

nmap <leader>ia  : call ConditionAnd()<CR>
func! ConditionAnd()
	if &filetype == "sh"
		call append(line(".") + 0, "if [ $# -lt 0 ] && [ -d "$dirname" ] ; then")
		call append(line(".") + 1, "    echo hello")
		call append(line(".") + 2, "fi")
		normal ddW
    elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
		call append(line(".") + 0, "    if ((i < j) && (i == j)) {")
		call append(line(".") + 1, "        i;")
		call append(line(".") + 2, "    }")
		normal ddfo2w
    elseif &filetype == "go"
        call append(line(".") + 0, "    if (i < j) && (i < j) {")
        call append(line(".") + 1, "        fmt.Println(\"i:\", i)")
        call append(line(".") + 4, "    }")
		normal ddfow
    elseif &filetype == "python"
        call append(line(".") + 0, "    if (ret < 0) and (ret == 0):")
        call append(line(".") + 1, "        ret")
		normal ddfow
    endif
endfunc

nmap <leader>io  : call ConditionOr()<CR>
func! ConditionOr()
	if &filetype == "sh"
		call append(line(".") + 0, "if [ $# -lt 0 ] || [ -d "$dirname" ] ; then")
		call append(line(".") + 1, "    echo hello")
		call append(line(".") + 2, "fi")
		normal ddW
    elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
		call append(line(".") + 0, "    if ((i < j) || (i == j)) {")
		call append(line(".") + 1, "        i;")
		call append(line(".") + 2, "    }")
		normal ddfo2w
    elseif &filetype == "go"
        call append(line(".") + 0, "    if (i < j) || (i == j) {")
        call append(line(".") + 1, "        fmt.Println(\"i:\", i)")
        call append(line(".") + 4, "    }")
		normal ddfow
    elseif &filetype == "python"
        call append(line(".") + 0, "    if (ret < 0) or (ret == 0):")
        call append(line(".") + 1, "        ret")
		normal ddfow
    endif
endfunc
nmap <leader>el  : call ConditionElseIf()<CR>
func! ConditionElseIf()
	if &filetype == "sh"
		call append(line(".") + 0, "else if [ $# -gt 0 ] ; then")
		call append(line(".") + 1, "    echo hello")
		call append(line(".") + 2, "else")
		call append(line(".") + 3, "    echo hello")
		call append(line(".") + 4, "fi")
		normal dd2W
    elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
		normal o<ESC>
		call append(line(".") + 0, "    else if (idx) {")
		call append(line(".") + 1, "        idx;")
		call append(line(".") + 2, "    } else {")
		call append(line(".") + 3, "        idx;")
		call append(line(".") + 4, "    }")
		normal ddkJfo4w
    elseif &filetype == "go"
		normal o<ESC>
		call append(line(".") + 0, "    else if idx {")
		call append(line(".") + 1, "        idx")
		call append(line(".") + 2, "    } else {")
		call append(line(".") + 3, "        idx")
		call append(line(".") + 4, "    }")
		normal ddkJfo3W
    elseif &filetype == "python"
		call append(line(".") + 0, "    elif ret != 0:")
        call append(line(".") + 1, "        ret")
		call append(line(".") + 2, "    else:")
		call append(line(".") + 3, "        ret")
		normal fojW
    endif
endfunc

nmap <leader>sw  : call ConditionSwitch()<CR>
func! ConditionSwitch()
	if &filetype == "sh"
		call append(line(".") + 0, "    case $v in")
		call append(line(".") + 1, "    mm)")
		call append(line(".") + 2, "        date +%M;")
		call append(line(".") + 3, "    ;;")
		call append(line(".") + 4, "    ss)")
		call append(line(".") + 5, "        date +%M;")
		call append(line(".") + 6, "    ;;")
		call append(line(".") + 7, "    *)")
		call append(line(".") + 8, "        echo \"wrong!again!\";")
		call append(line(".") + 9, "    ;;")
		call append(line(".") + 10, "    esac")
		normal ddfowl
    elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
		call append(line(".") + 0, "    switch () {")
		call append(line(".") + 1, "    case : {")
		call append(line(".") + 2, "        idx;")
		call append(line(".") + 3, "        break;")
		call append(line(".") + 4, "    }")
		call append(line(".") + 5, "")
		call append(line(".") + 6, "    default: {")
		call append(line(".") + 7, "        idx;")
		call append(line(".") + 8, "        break;")
		call append(line(".") + 9, "    }")
		call append(line(".") + 10, "    }")
		normal ddfowl
    elseif &filetype == "go"
		call append(line(".") + 0, "    switch args[0] {")
		call append(line(".") + 1, "    case \"hello\":")
		call append(line(".") + 2, "    case \"hello\":")
		call append(line(".") + 3, "    default:")
		call append(line(".") + 4, "    }")
		normal ddfowl
    elseif &filetype == "python"
        call append(line(".") + 0, "def jia(x,y):")
        call append(line(".") + 1, "    print x+y")
        call append(line(".") + 2, "")
        call append(line(".") + 3, "def jian(x,y):")
        call append(line(".") + 4, "    print x-y")
        call append(line(".") + 5, "")
        call append(line(".") + 6, "operator = {'+':jia,'-':jian}")
        call append(line(".") + 7, "")
        call append(line(".") + 8, "def f(x,o,y):")
        call append(line(".") + 9, "    operator.get(o)(x,y)")
        call append(line(".") + 10, "")
        call append(line(".") + 11, "f(3,'+',2)")
		normal ddW
    endif
endfunc

nmap <leader>wh  : call LoopWhile()<CR>
nmap <leader>fr  : call LoopWhile()<CR>
func! LoopWhile()
	if &filetype == "sh"
	    call append(line(".") + 0, "while true")
	    call append(line(".") + 1, "do")
	    call append(line(".") + 2, "    sleep 1")
	    call append(line(".") + 3, "done")
		normal ddw
	elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
	    call append(line(".") + 0, "    int idx = 0;")
        call append(line(".") + 1, "    while (idx < 20) {")
        call append(line(".") + 2, "        idx++;")
        call append(line(".") + 3, "    }")
		normal ddfow
    elseif &filetype == "go"
		call append(line(".") + 0, "    for idx, value := range arr {")
		call append(line(".") + 1, "        fmt.Println(idx, value)")
		call append(line(".") + 2, "    }")
		normal ddfow
    elseif &filetype == "python"
        call append(line(".") + 0, "count = 0")
        call append(line(".") + 1, "while (count < 9):")
        call append(line(".") + 2, "    print 'The count is:', count")
        call append(line(".") + 3, "    count = count + 1")
		normal ddjjfokk0
    endif
endfunc

nmap <leader>do  : call LoopDoWhile()<CR>
func! LoopDoWhile()
	if &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
	    call append(line(".") + 0, "    int idx = 0;")
        call append(line(".") + 1, "    do {")
        call append(line(".") + 2, "        idx++;")
        call append(line(".") + 3, "    } while(idx < 20);")
		normal ddfow
	endif
endfunc

nmap <leader>fo  : call LoopFor()<CR>
func! LoopFor()
	if &filetype == "sh"
        call append(line(".") + 0, "for id in ${pids}")
        call append(line(".") + 1, "do")
        call append(line(".") + 2, "    echo hello")
        call append(line(".") + 3, "done")
		normal ddw
    elseif &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
	    call append(line(".") + 0, "    int idx = 0;")
	    call append(line(".") + 1, "    for (idx = 0; idx < 10; idx++) {")
        call append(line(".") + 2, "        fmt.Println(\"hello %d\", idx)")
		call append(line(".") + 3, "    }")
		normal ddfow
    elseif &filetype == "go"
	    call append(line(".") + 0, "    for idx := 0; idx < len(arr); idx++ {")
        call append(line(".") + 1, "        fmt.Println(\"hello\", arr[idx])")
		call append(line(".") + 2, "    }")
		normal ddfow
   elseif &filetype == "python"
        call append(line(".") + 0, "    for v in arr:")
        call append(line(".") + 1, "        v")
		normal ddfoW
    endif
endfunc

nmap <leader>en  : call DefineEnum()<CR>
func! DefineEnum()
    if &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
		call append(line(".") + 0, "typedef enum tagE {")
        call append(line(".") + 1, "    VALUE = 0,")
        call append(line(".") + 2, "} E;")
		normal dd2w
    elseif &filetype == "go"
		call append(line(".") + 0, "type E int32")
		call append(line(".") + 1, "")
		call append(line(".") + 2, "const (")
		call append(line(".") + 3, "    E_A E = 0")
		call append(line(".") + 4, "    E_B E = 2")
		call append(line(".") + 5, ")")
		normal dd3jfow
    endif
endfunc

nmap <leader>st  : call DefineStruct()<CR>
func! DefineStruct()
    if &filetype == "h" || &filetype == "hpp" || &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
		call append(line(".") + 0, "typedef struct st_tag {")
        call append(line(".") + 1, "    int value;")
        call append(line(".") + 2, "} st_t, *st_p, st_a[1];")
		normal dd2w
    elseif &filetype == "go"
		call append(line(".") + 0, "type tag struct {")
		call append(line(".") + 1, "    value int32")
		call append(line(".") + 2, "    str string")
		call append(line(".") + 3, "}")
		normal ddjfokw
    endif
endfunc

nmap <leader>cl  : call DefineClass()<CR>
func! DefineClass()
    if &filetype == "h" || &filetype == "hpp" || &filetype == "cpp" || &filetype == "cc"
		call append(line(".") + 0, "/**")
		call append(line(".") + 1, " * description   : to .<br/><br/>")
		call append(line(".") + 2, " *")
		call append(line(".") + 3, " * @val          : value")
		call append(line(".") + 4, " **/")
		call append(line(".") + 5, "class A")
		call append(line(".") + 6, "{")
		call append(line(".") + 7, "    public:")
		call append(line(".") + 8, "        A();")
		call append(line(".") + 9, "        ~A();")
		call append(line(".") + 10, "")
		call append(line(".") + 11, "        func();")
		call append(line(".") + 12, "    private:")
		call append(line(".") + 13, "        int var;")
		call append(line(".") + 14, "};")
		normal ddj4w
    elseif &filetype == "go"
        call append(line(".") + 0, "type tag interface {")
        call append(line(".") + 1, "    Get() int")
        call append(line(".") + 2, "    Put(value int) int")
        call append(line(".") + 3, "}")
		normal ddjfokw
    elseif &filetype == "python"
		call append(line(".") + 0, "class Father(GrandPa):")
		call append(line(".") + 1, "    def __init__(self):")
		call append(line(".") + 2, "    print('I\'m Father!')")
		call append(line(".") + 3, "")
		call append(line(".") + 4, "class Son(Father):")
		call append(line(".") + 5, "    \"\"\" example \"\"\"")
		call append(line(".") + 6, "    i = 12345")
		call append(line(".") + 7, "")
		call append(line(".") + 8, "    def __init__(self):")
		call append(line(".") + 9, "        print('son constructor')")
		call append(line(".") + 10, "")
		call append(line(".") + 11, "    def sayHello(self):")
		call append(line(".") + 12, "        return 'hello world'")
		normal ddW
    endif
endfunc

nmap <leader>ma  : call MainFunc()<CR>
func! MainFunc()
    if &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
        call append(line(".") + 0, "int main(int argc, char** argv)")
        call append(line(".") + 1, "{")
        call append(line(".") + 2, "    return 0;")
        call append(line(".") + 3, "}")
		normal dd2jOa
    elseif &filetype == "go"
        call append(line(".") + 0, "func main() {")
        call append(line(".") + 1, "    fmt.Println(\"hello %T %#v\", v, v)")
        call append(line(".") + 2, "}")
		normal ddjOa
    elseif &filetype == "python"
		call append(line(".") + 0, "if __name__ == '__main__':")
        call append(line(".") + 1, "    cwd = os.path.dirname(os.path.realpath(__file__))")
        call append(line(".") + 2, "    log.init_log(cwd + '/log/backup.log')")
        call append(line(".") + 3, "    logging.info('backup starting...')")
		normal ddjfoW
    endif
endfunc

autocmd FileType h,hpp,c,cc,cpp,cxx nmap <leader>cde i#define<tab>A<tab>1<esc>hh
autocmd FileType h,hpp,c,cc,cpp,cxx nmap <leader>us iusing namespace ;<esc>i
""make&&errors(wrongs)
autocmd FileType h,hpp,c,cc,cpp,cxx nmap ew    :cw<CR>
autocmd FileType h,hpp,c,cc,cpp,cxx nmap ei    :cc<CR>
"autocmd FileType h,hpp,c,cc,cpp,cxx map ew    :copen
autocmd FileType h,hpp,c,cc,cpp,cxx nmap ep    :cp<CR>
autocmd FileType h,hpp,c,cc,cpp,cxx nmap en    :cn<CR>
autocmd FileType h,hpp,c,cc,cpp,cxx nmap el    :cl<CR>    "list all errors
autocmd FileType h,hpp,c,cc,cpp,cxx nmap eu    :cold<CR>
autocmd FileType h,hpp,c,cc,cpp,cxx nmap ed    :cnew<CR>

" 文件保存的时候，保证每行末尾没有多余的space，并保证最后一行为空
augroup prewrites
	autocmd!
	autocmd BufWritePre,FileWritePre * :%s/\s\+$//e | %s/\r$//e
augroup END

autocmd FileType go autocmd BufWritePre <buffer> Fmt
autocmd FileType go compiler go
autocmd FileType go set shiftwidth=4 | set expandtab " 用 space 代替 tab
"nmap    <leader>cu    ~
"nmap    <leader>cd    ~
nmap    <leader>wu    gUiw
nmap    <leader>wd    guiw
"nmap    <leader>ww    4w
"nmap    <leader>ee    4e
"nmap    <leader>lp    i<C-x><C-l><esc>
"nmap    <leader>ll    16l

"makefile
"gen so file method: g++ -fpic -shared -o libabc.so abc.o
"using so file method: g++ -o test test.cc /home/st/libabc.so
"using so file method if libabc.so is in /usr/lib: g++ -o test test.cc -labc
map <leader>cm0 i#makefile for those who has only a excutable file <CR><CR><esc>i.SUFFIXES: .sh .h .c .cc .cpp<CR><esc>i<CR><CR><esc>iCC = g++<CR><esc>iSRCS = $(wildcard ./src/*.cc)<CR><esc>iOBJS = $(patsubst ./src/%.cc, ./obj/%.o, $(SRCS))<CR><esc>iBIN = ./bin/linux_client<CR><esc>iSRC_DIR = ./src<CR><esc>iOBJ_DIR = ./obj<CR><esc>i<CR><esc>iFLAG=-Wall -g -rdynamic -DDEBUG<CR><esc>i<CR><esc>iall:$(BIN)<CR><esc>i<CR><esc>i#$(OBJS):$(SRCS)<CR><esc>i$(OBJ_DIR)/%.o:$(SRC_DIR)/%.cc<CR><esc>i<tab>$(CC) -c $(FLAG) -o $@ $<<CR><esc>i<CR><esc>i$(BIN):$(OBJS)<CR><esc>i<tab>$(CC) $(FLAG) -o $@  $^<CR><esc>i<CR><esc>icleanobj:<CR><esc>i<tab>rm -f $(OBJS)<CR><esc>i<CR><esc>iclean:<CR><esc>i<tab> make cleanobj<CR><esc>i<tab>-rm -f $(BIN) *~<CR><esc>i<CR><esc>idisplay:<CR><esc>i<tab>@echo $(BIN)<CR><esc>i<tab>@echo $(SRCS)<CR><esc>i<tab>@echo $(OBJS)<CR><esc>i<CR><esc>
map <leader>cm1 i#makefile for those who have many excutable files<CR><CR><esc>i.SUFFIXES: .sh .h .c .cc .cpp<CR><esc>i<CR><esc>iCXX = g++<CR><esc>iCXXFLAGS = -Wall -Werror  -fPIC -shared -D _AGENT_LARGE_VERSION_V3_<CR><esc>iCXX_MACRO =     <CR><esc>i<CR><esc>iSRC_DIR = src<CR><esc>iOBJ_DIR = obj<CR><esc>iBIN_DIR = bin<CR><esc>iBIN = get_city<CR><esc>i<CR><esc>iBASE_PATH = ../../../../base_proj/trunk/base<CR><esc>i<CR><esc>iINC_DIR = \<CR><esc>i<tab><tab>  -I./src/<tab>\<CR><esc>i<tab><tab>  -I /usr/local/mysql/include \<CR><esc>i<CR><esc>iLIB_DIR = \<CR><esc>i<tab><tab>  -L../lib \<CR><esc>i<tab><tab>  -L/usr/local/mysql/lib -lmysqlclient \<CR><esc>i<CR><esc>i<CR><esc>iall: clean debug release # strip<CR><esc>i<CR><esc>i<CR><esc>i<CR><esc>idebug release gprof:$(addprefix $(BIN_DIR)/,$(BIN))<CR><esc>i<CR><CR><esc>i$(OBJ_DIR)/%.o:$(SRC_DIR)/%.cc<CR><esc>i<tab>$(CXX) $(CXXFLAGS) $(CXX_MACRO) -o $@ $(INC_DIR) -c $<<CR><esc>i<CR><esc>i$(BIN_DIR)/get_city:$(addprefix $(OBJ_DIR)/, loca_conv.o get_city.o)<CR><esc>i<tab>$(CXX) $(CXXFLAGS) $(CXX_MACRO) -o $@ $^ $(LIB_DIR) <CR><esc>i<CR><esc>i<CR><esc>istrip:<CR><esc>i<tab>strip $(addprefix $(BIN_DIR)/,$(BINARY))<CR><esc>i<CR><esc>iclean:<CR><esc>i<tab>rm -f $(addprefix $(BIN_DIR)/,$(BIN)) $(OBJ_DIR)/*.o<CR><esc>i<CR><esc>i<CR><esc>isync:<CR><esc>i<tab>rsync -azvc $(BIN_DIR)/*  rsync://10.133.2.206:49000/client_cgi/cgi-bin/<CR><esc>i<CR><esc>iinstall:<CR><esc>i<tab>cp $(./bin/$(BIN)) ../qun.qq.com/cgi-bin/ <CR><esc>i<tab>cp qun.ini ../qun.qq.com/cgi-bin/ <CR><esc>i<CR><esc>
map <leader>cm2 i#makefile for those has only one excutable file <CR><CR><esc>i.SUFFIXES: .sh .h .c .cc .cpp<CR><CR>GAME=tetris<CR><esc>iCC = g++<CR><esc>i<CR><esc>iSRCS=$(shell ls *.cc)<CR><esc>iOBJS=$(SRCS:.cc=.o)<CR><esc>i<CR><esc>iall:$(GAME) cleanobj<CR><esc>i<CR><esc>i$(OBJS):%.o:%.cc<CR><esc>i<tab>@echo Compiling... $@<CR><esc>i<tab>$(CC) -g -c $<<CR><esc>i$(GAME): $(OBJS)<CR><esc>i<tab>$(CC) -g -o $@ $(OBJS) -lpthread -lrt<CR><esc>icleanobj:<CR><esc>i<tab>-rm -f $(OBJS)<CR><esc>iclean:<CR><esc>i<tab>-rm -f $(OBJS) $(GAME)<CR><esc>i<CR><esc>
"inoremap ,. <BS><Esc>   "instead of <Esc>

map Q gq
nmap    <leader>ts    :%s/\t/    /g<CR>
nmap    <leader>db    :%s/^$\n//g<CR>
nmap    <leader>du    :%s/\r//g<CR>
nmap    <leader>ds    :%s/\s\+$//g<CR>
nmap    <leader>d[    :%s/\n\t*{/\t{/g<CR>
nmap    <leader>de    :%s/\n\t*else/\telse/g<CR>
nmap    <leader>di    :%s/if(/if (/g<CR>
nmap    <leader>df    :%s/for(/for (/g<CR>
nmap    <leader>dw    :%s/while(/while (/g<CR>
"vim-diff
set     diffopt=context:14
nmap    <leader>dp    [c    ""pre diff
nmap    <leader>dn    ]c    ""next diff
nmap    <leader>dfp    dp    ""put diff
nmap    <leader>dfg    do    ""get diff
"left alignment        :[range] le(ft) textwidth
"map al :.,+3 left 80<CR>
"center alignment    :[range] ce(ter) textwidth
"map ac :.,+3 center 80<CR>
"right alignment        :[range] ri(ght) textwidth
"map ar :.,+3 right 80<CR>
"break up a line QQ
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" hot keys
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" move between spilt views using CTRL-j,k,h,l
nmap    qj    <C-W>j
nmap    qk    <C-W>k
nmap    qh    <C-W>h
nmap    ql    <C-W>l
"nmap    q=    <C-W>3+
"nmap    q-    <C-W>3-
nmap    q=    :resize +3<CR>
nmap    q-    :resize -3<CR>
nmap    q,    :vertical resize -3<CR>
nmap    q.    :vertical resize +3<CR>
nmap    qe    <C-w>v
nmap    qs    <C-w>s
nmap    qq    <esc>:q!<CR>
"TlistOpen or TlistClose or TlistToggle
"TlistToggle can open or close window automatically
nmap    qt    :TlistToggle<CR>
nmap    qb    :BufExplorer<CR>
nmap    qw    :WMToggle<CR><C-w><C-h>:set nonu<CR>
nmap    qu    :FirstExplorerWindow<CR>
nmap    qd    :BottomExplorerWindow<CR>
nmap    qn    :set nonu<CR>:set nolist<CR>:set fdm=indent<CR>
nmap    ss    :w<CR>
nmap    sf    :w<CR>
nmap    sq    :wq!<CR>
"nmap sh :source $VIMRUNTIME/syntax/2html.vim
"view file in hexadecimal by big-endian style. -r reverse ; -c 12, 12 chars every line; -i output in C include file style; -u use upper case hex letters
"nmap tx :%!xxd
"od [-A addr type] [-t view type] filename; A, can be o(8) or d(10) or  x(16) or n(not dispaly address); t can be c(char) or o(8) or d(signed 10) or u(unsigned 10) or x(16) or f(float)
"nmap to :%!od
""" move lines of text using ALT-j,k,h,l
nmap    md    ddp
nmap    mu    ddkP
"set fdm=marker
"zf10+    (fold later 10 lines)
"zf10-    (fold former 10 lines)
"zf%    (fold () or [] or {})
"zd        (unfold lines under current cursor)
"zD        (unfold recursively)
"zE        (unfold all lines)
"set fdm=indent
"zc        折叠
"zC        对所在范围内所有嵌套的折叠点进行折叠
"zo        展开折叠
"zO        对所在范围内所有嵌套的折叠点展开
"[z        到当前打开的折叠的开始处。
"]z        到当前打开的折叠的末尾处。
"zj        向下移动。到达下一个折叠的开始处。关闭的折叠也被计入。
"zk        向上移动到前一折叠的结束处。关闭的折叠也被计入
"zz put cur line to  the middle of the window, zt top, tb bottom
set fdm=indent
nmap    fc    zC
nmap    fo    zO
nmap    fp    zk
nmap    fn    zj
nmap    fd    zM
""""""""""""""""""""""""""""""
" => Vim grep
""""""""""""""""""""""""""""""
let Grep_Skip_Dirs = 'RCS CVS SCCS .svn generated'
set grepprg=/bin/grep\ -nH
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Remove the Windows ^M - when the encodings gets messed up
noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm
":buffers or :ls list buffers
":buffer 2 open 2th file
":sbuffer 2 要在一个新窗口中打开一个缓冲区
":bdelete 3 delete 3th buffer from buffer list and put it into unlisted buffer list
":bwipe 3 delete 3th buffer from buffer list and do not put it into unlisted buffer list
":bnext 跳转到下一个缓冲区
":bprevious 跳转到前一个缓冲区
":bfirst 跳转到第一个缓冲区
":blast 跳转到最后一个缓冲区
"Quickly open a buffer for scripbble
"map <leader>q :e ~/buffer<cr>
au BufRead,BufNewFile ~/buffer iab <buffer> xh1 ===========================================
"map <leader>pp :setlocal paste!<cr>
"set paste            "粘贴时取消自动换行
set pastetoggle=<F9>
augroup vimrcEx
    au!
    autocmd FileType text setlocal textwidth=78
    "自动跳到上一次打开的位置
    autocmd BufReadPost *
                \ if line("'\"") > 0 &&  line("'\"")  <=  line("$") |
                \ exe "normal g'\"" |
                \ endif
    au BufReadPost  *.hh, *.c, *.ec, *.cpp, *.hpp, *.ecpp, *.pc set foldexpr = FoldBrace()
    au BufReadPost  *.hh, *.c, *.ec, *.cpp, *.hpp, *.ecpp, *.pc set foldmethod = expr
    au BufReadPost  *.hh, *.c, *.ec, *.cpp, *.hpp, *.ecpp, *.pc set foldenable
    au BufWinLeave *.ztx mkview
    au BufWinEnter *.ztx silent loadview
    au BufNewFile, BufRead *.txt setf txt
augroup END

highlight Comment ctermfg=darkcyan
syntax enable
syntax on
if has("syntax")
    syntax on
endif

":autocmd!               删除所有之前的自动命令.
"vimrc被修改时，自动加载
autocmd! bufwritepost .vimrc source ~/.vimrc

if &t_Co > 2 || has("gui_running")
    syntax on
    set hlsearch
endif

if has("autocmd")
    au BufReadPost * if line ("'\"") > 1 && line ("'\"") <= line("$") | exe "normal! g'\"" | endif
    filetype plugin indent on
    autocmd FileType text setlocal textwidth=78
    autocmd BufReadPost *
                \ if line("'\"") > 0 && line("'\"") <= line("$") |
                \    exe "normal g'\"" |
                \ endif
endif

if v:progname =~? "evim"
    finish
endif

func! RemovePairs()
    let l:line = getline(".")
    let l:previous_char = l:line[col(".")-1] " 取得当前光标前一个字符
    if index(["(", "[", "{"], l:previous_char) != -1
        let l:original_pos = getpos(".")
        execute "normal %"
        let l:new_pos = getpos(".")
        " 如果没有匹配的右括号
        if l:original_pos == l:new_pos
            execute "normal! a\<BS>"
            return
        end
        let l:line2 = getline(".")
        if len(l:line2) == col(".")
            " 如果右括号是当前行最后一个字符
            execute "normal! v%xa"
        else
            " 如果右括号不是当前行最后一个字符
            execute "normal! v%xi"
        end
    else
        execute "normal! a\<BS>"
    end
endfunc
" 用退格键删除一个左括号时同时删除对应的右括号
inoremap <BS> <ESC>:call RemovePairs()<CR>a

func! RemoveNextDoubleChar(char)
    let l:line = getline(".")
    let l:next_char = l:line[col(".")] " 取得当前光标后一个字符
    if a:char == l:next_char
        execute "normal! l"
    else
        execute "normal! i" . a:char . ""
    end
endfunc

""map dr :call CurrectDir()<CR>
function! CurrectDir()
    return substitute(getcwd(), "", "", "g")
endfunction

"a 返回当前时间
"map tt :call GetTimeInfo()<CR>
func! GetTimeInfo()
    exec "w"
    exec "!clear;"
    let curtime = strftime('%Y-%m-%d %A %H:%M:%S')
    silent exec "!echo .curtime."
endfunction

"insert nums before every line
nmap <leader>nu :call InsertLineNum()<CR>  "可以把下列命令放入脚本文件.ins_line_num, 执行命令":so .ins_line_num"即可
func! InsertLineNum()
    %s/^/  /          " 每一行的行首添加一个TAB字符
    $                 " 到文件的末行
    let end=line(".") " 末行的行号 ==〉变量 END，函数line的功能是取得指定行的行号，此处参数"."表示当前行
    1                 " 到文件的首行
    "------------------------------------------
    let num=1         " 1 ==〉计数器
    while num<=end
        let  line=getline(".")   " 取当前行的内容 ==〉变量 LINE
        let  line=substitute(line,$,num,"")  "  在变量 LINE 的前面置入行号
        call setline(".",line)   " 将变量 LINE 的内容写回当前行
        +              " 下移一行
        let  num=num+1 " 计数器加一
    endwhile           " 循环执行，直到文件结束
endfunc

nmap <leader>nnu :call InsertLineNum()<CR>  "可以把下列命令放入脚本文件.ins_line_num, 执行命令":so .ins_line_num"即可
func! InsertLineNum()
    1,$s/^[0-9]\{1,}\s\+//g     "\s\+ space
endfunc

"F7 save&compile
"autocmd FileType h,hpp,c,cc,cpp,cxx  nmap <leader>cscm  :call Compile()<CR>
func! Compile()
    silent exec "w"
    silent exec "!clear;"
    silent exec "!echo Start Compiling......"
    if &filetype == "c"
        silent exec "!echo gcc -c -Wall -rdynamic -O2 -o %<.o %"
        silent exec "!gcc -c -Wall -rdynamic -O2 -o %<.o %"
    elseif &filetype == "cpp" || &filetype == "cc"
        silent exec "!echo g++ -c -Wall -rdynamic -D_GLIBCXX_USE_NANOSL -D_GLIBCXX_USE_NANOSLEEP -D_GLIBCXX_USE_SCHED_YIELD -std=c++11 -O2 -o %<.o %"
        silent exec "!g++ -c -Wall -rdynamic -D_GLIBCXX_USE_NANOSL -D_GLIBCXX_USE_NANOSLEEP -D_GLIBCXX_USE_SCHED_YIELD -std=c++11 -O2 -o %<.o %"
    endif
    silent exec "!echo Compile over."
    exec "!echo  "
endfunc

"F7 compile
"map \cmpso :call CompileSO()<CR>
func! CompileSO()
    exec "w"
    exec "!clear;"
    silent exec "!echo Start Compiling......"
    if &filetype == "c"
        exec "!gcc -fpic -shared -Wall -lpthread -lrt -rdynamic -O2 -o %<.so %"
    elseif &filetype == "cpp" || &filetype == "cc"
        exec "!g++ -fpic -shared -Wall -lpthread -lrt -rdynamic -D_GLIBCXX_USE_NANOSL -D_GLIBCXX_USE_NANOSLEEP -D_GLIBCXX_USE_SCHED_YIELD -std=c++11 -O2 -o %<.so %"
    elseif &filetype == "erl"
        exec "!erlc %"
    endif
    silent exec "!echo Compile over."
    silent exec "!echo  "
endfunc

"F6 save&link
"autocmd FileType h,hpp,c,cc,cpp,cxx  nmap <leader>csl  :call LinkGcc()<CR>
func! LinkGcc()
    silent exec "w"
    silent exec "!clear;"
    silent exec "!echo Start Compiling and Linking......"
    if &filetype == "c"
        silent exec "!echo gcc -lpthread -lrt -rdynamic -Wall -O2 -o %< %"
        silent exec "!gcc -lpthread -lrt -rdynamic -Wall -O2 -o %< %"
    elseif &filetype == "cpp" || &filetype == "cc"
        silent exec "!echo g++ -lpthread -lrt -rdynamic -D_GLIBCXX_USE_NANOSL -D_GLIBCXX_USE_NANOSLEEP -D_GLIBCXX_USE_SCHED_YIELD -std=c++11 -Wall -O2 -o %< %"
        silent exec "!g++ -lpthread -lrt -rdynamic -D_GLIBCXX_USE_NANOSL -D_GLIBCXX_USE_NANOSLEEP -D_GLIBCXX_USE_SCHED_YIELD -std=c++11 -Wall -O2 -o %< %"
    endif
    silent exec "!echo Compile and Link over."
    exec "!echo "
endfunc

"F3 link&recording error
"autocmd FileType h,hpp,c,cc,cpp,cxx  nmap <leader>cse :call LinkRec()<CR>
func! LinkRec()
    silent exec "w"
    silent exec "!clear;"
    silent exec "!echo Start Compiling and Linking......"
    if &filetype == "c"
        silent exec "!echo gcc -Wall -lpthread -lrt -rdynamic -O2 -o %< % 2> link.html"
        silent exec "!gcc -Wall -lpthread -lrt -rdynamic -O2 -o %< % 2> link.html"
    elseif &filetype == "cpp" || &filetype == "cc"
        silent exec "!echo g++ -Wall -lpthread -lrt -rdynamic -O2 -o %< % 2> link.html"
        silent exec "!g++ -Wall -lpthread -lrt -rdynamic -O2 -o %< % 2> link.html"
    endif
    silent exec "!echo Compile and Link over."
    silent exec "!echo "
endfunc

"F5 save & debug
autocmd FileType h,hpp,c,cc,cpp,cxx nmap <leader>sd :call Debug()<CR>
func!  Debug()
    silent exec "w"
    silent exec "!clear;"
    silent exec "!echo  Start Compiling"
    if &filetype == "c"
        silent exec "!gcc -gstabs+ -Wall -lpthread -lrt -o %< %"
    elseif &filetype == "cpp" || &filetype == "cc"
        silent exec "!g++ -gstabs+ -Wall -lpthread -lrt -D_GLIBCXX_USE_NANOSL -D_GLIBCXX_USE_NANOSLEEP -D_GLIBCXX_USE_SCHED_YIELD -std=c++11 -o %< %"
    endif
    silent exec "!echo Compile over."
    silent exec "!echo "
    silent exec "!echo start debugging"
    silent exec "!echo  "
    silent exec "!chmod u+rx ./%<"
    silent exec "!gdb ./%<"
endfunc

"F4 save & run
nmap <leader>sr  :call Run()<CR>
func!  Run()
    silent exec "w"
    silent exec "!clear;"
    silent exec "!echo  Start Compiling......"
    if &filetype == "c"
        silent exec "!echo gcc -Wall -lpthread -lrt -rdynamic -O2 -I./ -o %< %"
        silent exec "!gcc -Wall -lpthread -lrt -rdynamic -I./ -O2 -o %< %"
    elseif &filetype == "cpp" || &filetype == "cc"
        silent exec "!echo g++ -Wall -lpthread -lrt -rdynamic -D_GLIBCXX_USE_NANOSL -D_GLIBCXX_USE_NANOSLEEP -D_GLIBCXX_USE_SCHED_YIELD -std=c++11 -I./ -O2 -o %< %"
        silent exec "!g++ -Wall -lpthread -lrt -rdynamic -O2 -D_GLIBCXX_USE_NANOSL -D_GLIBCXX_USE_NANOSLEEP -D_GLIBCXX_USE_SCHED_YIELD -std=c++11 -I./ -o %< %"
    elseif &filetype == "go"
        silent exec "!echo go run %"
        silent exec "!go run %"
    elseif &filetype == "sh"
        silent exec "!echo sh %"
        silent exec "!sh %"
    elseif &filetype == "python"
        silent exec "!echo python %"
        silent exec "!python %"
    elseif &filetype == "lua"
        silent exec "!echo lua %"
        silent exec "!lua %"
    endif
    if &filetype == "c" || &filetype == "cpp" || &filetype == "cc"
        silent exec "!echo Compile over."
        silent exec "!echo start running..."
        silent exec "!chmod u+rx ./%<"
        silent exec "!./%<"
    endif
    exec "!echo "
endfunc

"F2 save & remove object
autocmd FileType h,hpp,c,cc,cpp,cxx nmap <leader>sc :call RmObjFile()<CR>
func! RmObjFile()
    silent exec "w"
    silent exec "!clear;"
    silent exec "!start cleaning obj files and bin files"
    silent exec "!echo rm -rf ./*.o ./%<"
    silent exec "!rm -rf ./*.o ./%<"
    silent exec "!echo clean over."
    exec "!echo "
endfunc

nmap <leader>si  : call Substitute()<CR>
function! Substitute()
    call inputsave()
    let g:MyPattern = inputdialog("Pattern: ", expand("<cword>"))
    let g:MySubs = inputdialog("Substitution (" . g:MyPattern . ") : ")
    silent exec '%s/' . g:MyPattern . '/' . g:MySubs . '/g'
    call inputrestore()
    silent exec "w"
endfunction

nmap <leader>ss  : call SearchString()<CR>
function! SearchString()
    silent exec "!clear;"
    let g:MyPattern = inputdialog("Pattern: ", expand("<cword>"))
    silent exec '!grep -inR ' . g:MyPattern . ' ./*'
    silent exec "!echo search over."
    exec "!echo "
endfunction

nmap <leader>se        :e ./
"nmap se  :call SaveAndEdit()<CR>
function! SaveAndEdit()
    silent exec "w"
    if has("win32")
        let filename = inputdialog("Edit file: ", expand(""))
    else
        let filename = inputdialog("Edit file: ", expand("./"))
    end
    if filename != ""
        silent exec "e " filename
    endif
endfunction

if &term=="xterm"
    set t_Co=8
    set t_Sb=^[[4%dm
    set t_Sf=^[[3%dm
endif

if v:progname =~? "evim"
    finish
endif


""""""""""""""""""""""""""""""
" => Visual mode related
""""""""""""""""""""""""""""""
" Really useful!
"  In visual mode when you press * or # to search for the current selection
vnoremap <silent> * :call VisualSearch('f')<CR>
vnoremap <silent> # :call VisualSearch('b')<CR>

" When you press gv you vimgrep after the selected text
vnoremap <silent> gv :call VisualSearch('gv')<CR>
nmap <leader>g :vimgrep // **/*.<left><left><left><left><left><left><left>


function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction

" From an idea by Michael Naumann
function! VisualSearch(direction) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

"set help docs
let helptags=$VIMFILES."/doc"
set helplang=cn
"set nobomb

"""""""""""""""""""""""""""""""
" plugin TagList
"""""""""""""""""""""""""""""""
filetype plugin on
if has("win32")
let Tlist_Ctags_Cmd = "D:/Program Files/Vim/vim73/ctags.exe"
else
let Tlist_Ctags_Cmd = '/home/alex/bin/ctags'
endif
let Tlist_Sort_Type                    = 'name'    "使taglist以tag名字进行排序
let Tlist_Auto_Open                    = 0            "打开文件时候自动打开taglist
let Tlist_Show_One_File                = 0            "不同时显示多个文件的tag，只显示当前文件的
let Tlist_Exit_OnlyWindow            = 1            "如果taglist窗口是最后一个窗口，则退出vim
let Tlist_Use_Right_Window            = 1            "在右侧窗口中显示taglist窗口
let Tlist_Use_SingleClick            = 1            "单击tag就跳转到定义
let Tlist_GainFocus_On_ToggleOpen    = 1            "使用:TlistToggle打开taglist窗口时，输入焦点在taglist窗口中
let Tlist_WinWidth                    = 25        "set window width
"let    Tlist_WinHeight                    = 10    "set window height
"let    Tlist_Use_Horiz_Window            = 10    "show window vertically
if has("win32")
nmap :!ctags-R -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+lS --fields=+iaS --extra=+q  -f ~\\tags .\\*
set autochdir
set tags+=.\\tags "get tags automatically
else
"if has("linux")
nmap :ctags -R -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p ---fields=+lS -fields=+iaS --extra=+q  -f ~/.vim/systags ~/*
set tags+=~/.vim/systags
endif

au GUIENTER * simalt ~x    "au = autocmd

""""""""""""""""""""""""""""""
" plugin BufExplorer
"""""""""""""""""""""""""""""""
let g:bufExplorerDefaultHelp        =    0        " Do not show default help.
let g:bufExplorerShowRelativePath    =    1        " Show relative paths.
let g:bufExplorerSortBy                =    'mru'    " Sort by most recently used.
let g:bufExplorerSplitRight            =    1        " Split left.
let g:bufExplorerSplitVertical        =    0        " Split vertically.
let g:bufExplorerSplitVertSize        =    15        " Split width
let g:bufExplorerUseCurrentWindow    =    0        " Open in new window.
autocmd BufWinEnter \[Buf\ List\] setl nonumber ]

""""""""""""""""""""""""""""""
"plugin Winmanager
"""""""""""""""""""""""""""""""
"g:var, var is a global variable
let g:winManagerWindowLayout    =    'FileExplorer|BufExplorer'
""只剩一个窗口时, 退出vim.
let g:persistentBehaviour        =    0
let g:winManagerWidth            =    25
let g:defaultExplorer            =    0

"""""""""""""""""""""""""""""""
"plugin Omnicppcomplete
"""""""""""""""""""""""""""""""
":helptags $HOME/.vim/
set    completeopt=menu,menuone ",preview ,longest
let    OmniCpp_MayCompleteDot        =    1                " autocomplete with .
let    OmniCpp_MayCompleteArrow    =    1                " autocomplete with ->
let    OmniCpp_MayCompleteScope    =    1                " autocomplete with ::
let    OmniCpp_SelectFirstItem        =    1                " select first item (but don't insert)
let    OmniCpp_NamespaceSearch        =    2                " search namespaces in this and included files
let    OmniCpp_ShowPrototypeInAbbr    =    0                " show function prototype  in popup window
let    OmniCpp_ShowScopeInAbbr        =    1                " show function prototype
let    OmniCpp_GlobalScopeSearch    =    1
let    OmniCpp_DisplayMode            =    1
let    OmniCpp_DefaultNamespaces    =    ["std"]

"""""""""""""""""""""""""""""""
"plugin Echofunc
"""""""""""""""""""""""""""""""
"ctags -R --fields=+lS
let g:EchoFuncKeyPrev='<C-u>'
let g:EchoFuncKeyNext='<C-d>'

"""""""""""""""""""""""""""""""
"plugin a.vim
"""""""""""""""""""""""""""""""
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>aa    :A<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>as    :AS<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>ae    :AV<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>at    :AT<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>an    :AN<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>ih    :H<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>is    :IHS<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>ie    :IHV<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>it    :IHT<CR>
"autocmd FileType h,hpp,c,cc,cpp nmap    <leader>wn    :IHN<CR>
"<leader>ih        相当于:H
"<leader>is        切换至光标所在处(单词所指)文件的配对文件
"<Leader>ihn    在多个匹配文件间循环切换
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>wp    :tabprev<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>wn    :tabnext<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>wf    :tabfirst<CR>
autocmd FileType h,hpp,c,cc,cpp nmap    <leader>wl    :tablast<CR>

